
## Типы данных

При определении таблицы для всех ее столбцов необходимо указать тип данных. 

Тип данных определяет диапазон значений, которые могут храниться в столбце, сколько они будут занимать места в памяти. 

`PostgreSQL` поддерживает богатую палитру различных типов данных, среди которые условно можно разделить на подгруппы: числовые, символьные, логические, дата и время, бинарные и ряд других.

## Числовые типы данных

Группа числовых типов данных включает в себя целый ряд разновидностей: целочисленные типы, числа фиксированной точности, типы данных с плавающей точкой, последовательные типы (`serial`)

В составе целочисленных типов находятся следующие представители: `smallint, integer, bigint`. 

Если атрибут таблицы имеет один из этих типов, то он позволяет хранить только целочисленные данные. 
При этом перечисленные типы различаются по количеству байтов, выделяемых для хранения данных. 

В `PostgreSQL` существуют псевдонимы для этих стандартизированных имен типов, а именно: `int2, int4 и int8`.

Число байтов отражается в имени типа.


* `serial`: представляет автоинкрементирующееся числовое значение, которое занимает 4 байта и может хранить числа от 1 до 2147483647. 

Значение данного типа образуется путем автоинкремента значения предыдущей строки. Поэтому, как правило, данный тип используется для определения идентификаторов строки.

* `smallserial`: представляет автоинкрементирующееся числовое значение, которое занимает 2 байта и может хранить числа от 1 до 32767. 
Аналог типа `serial` для небольших чисел.

* `bigserial`: представляет автоинкрементирующееся числовое значение, которое занимает 8 байт и может хранить числа от 1 до 9223372036854775807. Аналог типа `serial` для больших чисел.

* `smallint`: хранит числа от `-32768 до +32767`. Занимает 2 байта. Имеет псевдоним int2.

* `integer`: хранит числа от `-2147483648 до +2147483647`. Занимает 4 байта. Имеет псевдонимы int и int4.

* `bigint`: хранит числа от `-9223372036854775808` до `+9223372036854775807`. Занимает 8 байт. Имеет псевдоним int8.

* `numeric`: хранит числа с фиксированной точностью, которые могут иметь до 131072 знаков в целой части и до 16383 знаков после запятой.

Данный тип может принимать два параметра `precision и scale: numeric(precision, scale)`.

Параметр `precision` указывает на максимальное количество цифр, которые может хранить число.

Параметр `scale` представляет максимальное количество цифр, которые может содержать число после запятой. 

Это значение должно находиться в диапазоне от 0 до значения параметра `precision`. По умолчанию оно равно 0.

Например, для числа 23.5141 `precision` равно 6, а scale - 4.

* `decimal`: хранит числа с фиксированной точностью, которые могут иметь до `131072` знаков в целой части и до `16383` знаков в дробной части. То же самое, что и `numeric`.

* `real` хранит числа с плавающей точкой из диапазона от `1E-37 до 1E+37`. Занимает 4 байта. Имеет псевдоним `float4`.

* `double precision`: хранит числа с плавающей точкой из диапазона от `1E-307 до 1E+308`. Занимает 8 байт. Имеет псевдоним `float8`.

Примеры использования:

```sql

select 1/3::numeric as res;
select 1/3 ::integer as res;
select 1/3 ::smallint as res;
select 1/3 ::real as res;

select 3+1/3::numeric as res;

select 3+1/3::numeric(2,1) as res;

select 3.14::numeric(3,2) as res;
select 3.14::numeric(3,1) as res;
select 3.14::numeric(5,4) as res;

select 3+1/3::real as res;
select 3+1/3::float4 as res;

select 3+1/3::float8 as res;
select 3+1/3::double precision as res;

select 1.23::money as money;
SELECT '12.34'::float8::numeric::money;

```

Представителями типов данных с плавающей точкой являются типы `real и double precision`. 

Они представляют собой реализацию стандарта `IEEE «Standard 754 for Binary Floating-Point Arithmetic»`. 

Тип данных `real` может представить числа в диапазоне, как минимум, от `1E−37 до 1E+37` с точностью не меньше `6` десятичных цифр.

Тип double precision имеет диапазон значений примерно от `1E−307 до 1E+308` с точностью не меньше 15 десятичных цифр.
При попытке записать в такой столбец слишком большое или слишком маленькое значение будет генерироваться ошибка. 

Если точность вводимого числа выше допустимой, то будет иметь место округление значения.

А вот при вводе очень маленьких чисел, которые невозможно представить значениями, отличными от нуля, будет генерироваться ошибка потери значимости, или исчезновения значащих разрядов (an underflow error).

```sql
SELECT 0.1::real * 10;
SELECT 0.1::real * 10 = 1.0::real;

```


## Типы для работы с валютой (денежными единицами)

Для работы с денежными единицами определен тип `money`, который может принимать значения в диапазоне от `-92233720368547758.08 до +92233720368547758.07` и занимает 8 байт.

## Символьные типы

* character(n): представляет строку из фиксированного количества символов. С помощью параметра задается задается количество символов в строке. Имеет псевдоним char(n).

```sql
select 'abcde'::char(2) as res;
select 'abcde'::character(3) as res;
select 'abcde'::character(30) as res;
select 'abcde'::varchar(3) as res;
```

* character `varying(n)`: представляет строку из переменной длины. 

С помощью параметра задается задается максимальное количество символов в строке. Имеет псевдоним `varchar(n)`.

`text`: представляет текст произвольной длины.

Константы символьных типов в `SQL`-командах заключаются в одинарные кавычки.

```sql
SELECT 'PostgreSQL';
```

В том случае, когда в константе содержится символ одинарной кавычки или обратной косой черты, их необходимо удваивать

```sql
SELECT 'PGDAY''17';
```

В том случае, когда таких символов в константе много, все выражение становится трудно воспринимать. На помощь может прийти использование удвоенного символа «$». 

Эти символы выполняют ту же роль, что и одинарные кавычки, когда в них заключается строковая константа. 

При использовании символов «$» в качестве ограничителей уже не нужно удваивать никакие символы, содержащиеся в самой константе:
ни одинарные кавычки, ни символы обратной косой черты.

```sql
SELECT $$PGDAY'17'$$;
```
Возможность использования символов доллара в роли ограничителей символьной константы не является частью стандарта SQL. 
Это расширение, предлагаемое `PostgreSQL`.

## Строковые константы

PostgreSQL предлагает еще одно расширение стандарта SQL — строковые константы в стиле языка C. 

Чтобы иметь возможность их использовать, нужно перед начальной одинарной кавычкой написать символ «E».

Например, для включения в константу символа новой строки нужно сделать так:

```sql
SELECT E'PGDAY\t\t17\n100';
```


При использовании C-стиля необходимо удваивать обратную косую черту, если требуется поместить ее в константу буквально. 
А для включения в содержимое константы символа обратной кавычки можно либо удвоить ее, либо сделать так:

```sql
SELECT E'PGDAY\'17';
```

## Бинарные данные

Для хранения бинарных данных определен тип bytea. 

Он хранит данные в виде бинарных строк, которые представляют последовательность `октетов` или `байт`.



## Логический тип

Тип `boolean` может хранить одно из двух значений: `true или false`.

Вместо `true` можно указывать следующие значения: `TRUE, 't', 'true', 'y', 'yes', 'on', '1'`.

Вместо `false` можно указывать следующие значения: `FALSE, 'f', 'false', 'n', 'no', 'off', '0'`.

Типы для представления интернет-адресов

* cidr: интернет-адрес в формате IPv4 и IPv6. Например, 192.168.0.1. 

Занимает от 7 до 19 байт.

* inet: интернет-адрес в формате cidr/y, где cidr это адрес в формате IPv4 или IPv6, а /y - количество бит в адресе (если этот параметр не указан, то используется 34 для IPv4, 128 для IPv6). Например, 192.168.0.1/24 или 2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128. Занимает от 7 до 19 байт.

* macaddr: хранит MAC-адрес. Занимает 6 байт.

* macaddr8: хранит MAC-адрес в формате EUI-64. Занимает 8 байт.

# Геометрические типы

* point: представляет точку на плоскости в формате (x,y). Занимает 16 байт.

* line: представляет линию неопределенной длины в формате {A,B,C}. Занимает 32 байта.

* lseg: представляет отрезок в формате ((x1,y1),(x2,y2)). Занимает 32 байта.

* box: представляет прямоугольник в формате ((x1,y1),(x2,y2)). Занимает 32 байта.

* path: представляет набор содиненных точек. В формате ((x1,y1),...) путь является закрытым (первая и последняя точка соединяются линией) и фактически представляет многоугольник. В формате [(x1,y1),...] путь является открытым Занимает 16+16n байт.

* polygon: представляет многоугольник в формате ((x1,y1),...). Занимает 40+16n байт.

* circle: представляет окружность в формате <(x,y),r>. Занимает 24 байта.

Остальные типы данных

* json: хранит данные json в текстовом виде.

* jsonb: хранит данные json в бинарном формате.

* uuid: хранит универсальный уникальный идентификатор (UUID), например, a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11. Занимает 32 байта.

* xml: хранит даные в формате XML.

# Ограничения столбцов и таблиц


При определении таблиц и их столбцов в SQL мы можем использовать ряд атрибутов, которые накладывают определенные ограничения. Рассмотрим эти атрибуты.

## PRIMARY KEY

С помощью выражения PRIMARY KEY столбец можно сделать первичным ключом.

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(30),
    LastName CHARACTER VARYING(30),
    Email CHARACTER VARYING(30),
    Age INTEGER
)
```

Первичный ключ уникально идентифицирует строку в таблице. 

![alt text](image-3.png)

![alt text](image-2.png)

В качестве первичного ключа необязательно должны выступать столбцы с типом `SERIAL`, они могут представлять любой другой тип.

Установка первичного ключа на уровне таблицы:


```sql
CREATE TABLE Customers
(
    Id SERIAL,
    FirstName CHARACTER VARYING(30),
    LastName CHARACTER VARYING(30),
    Email CHARACTER VARYING(30),
    Age INTEGER,
    PRIMARY KEY(Id)
);
```


![alt text](image-4.png)

Первичный ключ может быть составным `compound key`. 

Такой ключ может потребоваться, если у нас сразу два столбца должны уникально идентифицировать строку в таблице. 

Например:

```sql
CREATE TABLE OrderLines
(
    OrderId INTEGER,
    ProductId INTEGER,
    Quantity INTEGER,
    Price MONEY,
    PRIMARY KEY(OrderId, ProductId)
);
```
![alt text](image-5.png)

Здесь поля `OrderId` и `ProductId` вместе выступают как составной первичный ключ. 

![alt text](image-6.png)

То есть в таблице `OrderLines` не может быть двух строк, где для обоих из этих полей одновременно были бы одни и те же значения.

## UNIQUE

Если мы хотим, чтобы столбец имел только уникальные значения, то для него можно определить атрибут `UNIQUE`.

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30) UNIQUE,
    Phone CHARACTER VARYING(30) UNIQUE,
    Age INTEGER
);
```

В данном случае столбцы, которые представляют электронный адрес и телефон, будут иметь уникальные значения. 
![alt text](image-7.png)


![alt text](image-8.png)

И мы не сможем добавить в таблицу две строки, у которых значения для этих столбцов будет совпадать.

Также мы можем определить этот атрибут на уровне таблицы:

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30),
    Phone CHARACTER VARYING(30),
    Age INTEGER,
    UNIQUE(Email, Phone)
);
```

Или так:

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30),
    Phone CHARACTER VARYING(30),
    Age INTEGER,
    UNIQUE(Email), 
    UNIQUE(Phone)
);
```

## NULL и NOT NULL

Чтобы указать, может ли столбец принимать значение `NULL`, при определении столбца ему можно задать атрибут `NULL` или `NOT NULL`. 

Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение `NULL`. 

Исключением является тот случай, когда столбец выступает в роли первичного ключа - в этом случае по умолчанию столбец имеет значение `NOT NULL`.


```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20) NOT NULL,
    LastName CHARACTER VARYING(20) NOT NULL,
    Age INTEGER
);

```

![alt text](image-9.png)

## DEFAULT

Атрибут `DEFAULT` определяет значение по умолчанию для столбца. 

Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет использоваться значение по умолчанию.

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Age INTEGER DEFAULT 18
);
```

![alt text](image-10.png)

Здесь для столбца `Age` предусмотрено значение по умолчанию `18`.

## CHECK

Ключевое слово `CHECK` задает ограничение для диапазона значений, которые могут храниться в столбце.

Для этого после слова `CHECK` указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. 

Например, возраст клиентов не может быть меньше `0` или больше `100`:

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Age INTEGER DEFAULT 18 CHECK(Age >0 AND Age < 100),
    Email CHARACTER VARYING(30) UNIQUE CHECK(Email !=''),
    Phone CHARACTER VARYING(20) UNIQUE CHECK(Phone !='')
);
```
![alt text](image-11.png)


Здесь также указывается, что столбцы `Email` и `Phone` не могут иметь пустую строку в качестве значения (пустая строка не эквивалентна значению `NULL`).

![alt text](image-12.png)

Для соединения условий используется ключевое слово `AND`. 

Условия можно задать в виде операций сравнения больше `(>)`, меньше `(<)`, не равно `(!=)`.

Также с помощью `CHECK` можно создать ограничение в целом для таблицы:

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    Age INTEGER DEFAULT 18,
    FirstName CHARACTER VARYING(20),
    LastName CHARACTER VARYING(20),
    Email CHARACTER VARYING(30) UNIQUE,
    Phone CHARACTER VARYING(20) UNIQUE,
    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
);
```

![alt text](image-13.png)
```sql
age > 0 AND age < 100 AND email::text <> ''::text AND phone::text <> ''::text
```

## Оператор CONSTRAINT. Установка имени ограничений.


С помощью ключевого слова `CONSTRAINT` можно задать имя для ограничений. 

В качестве ограничений могут использоваться `PRIMARY KEY, UNIQUE, CHECK`.

Имена ограничений можно задать на уровне столбцов. 

Они указываются после `CONSTRAINT` перед атрибутами:

```sql
CREATE TABLE Customers
(
    Id SERIAL CONSTRAINT customer_Id PRIMARY KEY,
    Age INTEGER CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),
    FirstName CHARACTER VARYING(20) NOT NULL,
    LastName CHARACTER VARYING(20) NOT NULL,
    Email CHARACTER VARYING(30) CONSTRAINT customers_email_key UNIQUE,
    Phone CHARACTER VARYING(20) CONSTRAINT customers_phone_key UNIQUE
);
```

В принципе необязательно задавать имена ограничений, при установке соответствующих атрибутов SQL Server автоматически определяет их имена. Но, зная имя ограничения, мы можем к нему обращаться, например, для его удаления.

И также можно задать все имена ограничений через атрибуты таблицы:

```sql
CREATE TABLE Customers
(
    Id SERIAL,
    Age INTEGER,
    FirstName CHARACTER VARYING(20) NOT NULL,
    LastName CHARACTER VARYING(20) NOT NULL,
    Email CHARACTER VARYING(30),
    Phone CHARACTER VARYING(20),
    CONSTRAINT customer_Id PRIMARY KEY(Id),
    CONSTRAINT customers_age_check CHECK(Age >0 AND Age < 100),
    CONSTRAINT customers_email_key UNIQUE(Email),
    CONSTRAINT customers_phone_key UNIQUE(Phone)
);
```

Вне зависимости от того, используется оператор CONSTRAINT для создания ограничений или нет (в этом случае при установке ограничений PostgreSQL сам дает им имена), мы можем просмотреть все ограничения в pgAdmin в узле базы данных в подузле :


![alt text](image.png)

## Внешние ключи

Для связи между таблицами применяются внешние ключи. Внешний ключ устанавливается для столбца из зависимой, подчиненной таблицы (referencing table), и указывает на один из столбцов из главной таблицы (referenced table). Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

Общий синтаксис установки внешнего ключа на уровне столбца:

```sql
REFERENCES главная_таблица (столбец_главной_таблицы)
    [ON DELETE {CASCADE|RESTRICT}]
    [ON UPDATE {CASCADE|RESTRICT}]
```

Чтобы установить связь между таблицами, после ключевого слова REFERENCES указывается имя связанной таблицы и далее в скобках имя столбца из этой таблицы, на который будет указывать внешний ключ. После выражения REFERENCES может идти выражение ON DELETE и ON UPDATE, которые уточняют поведение при удалении или обновлении данных.

Общий синтаксис установки внешнего ключа на уровне таблицы:

```sql
FOREIGN KEY (стобец1, столбец2, ... столбецN) 
    REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
    [ON DELETE {CASCADE|RESTRICT}]
    [ON UPDATE {CASCADE|RESTRICT}]
```


Например, определим две таблицы и свяжем их посредством внешнего ключа:

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    Age INTEGER, 
    FirstName VARCHAR(20) NOT NULL
);
  
CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER REFERENCES Customers (Id),
    Quantity INTEGER
);

```


Здесь определены таблицы Customers и Orders. Customers является главной и представляет клиента. Orders является зависимой и представляет заказ, сделанный клиентом. Эта таблица через столбец CustomerId связана с таблицей Customers и ее столбцом Id. То есть столбец CustomerId является внешним ключом, который указывает на столбец Id из таблицы Customers.

Определение внешнего ключа на уровне таблицы выглядело бы следующим образом:

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    Age INTEGER, 
    FirstName VARCHAR(20) NOT NULL
);
  
CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER,
    Quantity INTEGER,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id)
);
```

## ON DELETE и ON UPDATE

С помощью выражений ON DELETE и ON UPDATE можно установить действия, которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы. Для установки подобного действия можно использовать следующие опции:

CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.

RESTRICT: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. То есть фактически какие-либо действия отсутствуют.

NO ACTION: действие по умолчанию, предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице. И генерирует ошибку. В отличие от RESTRICT выполняет отложенную проверку на связанность между таблицами.

SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.

SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию, то в качестве него применяется значение NULL.

Каскадное удаление
По умолчанию, если на строку из главной таблицы по внешнему ключу ссылается какая-либо строка из зависимой таблицы, то мы не сможем удалить эту строку из главной таблицы. Вначале нам необходимо будет удалить все связанные строки из зависимой таблицы. И если при удалении строки из главной таблицы необходимо, чтобы были удалены все связанные строки из зависимой таблицы, то применяется каскадное удаление, то есть опция CASCADE:

```sql
CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER,
    Quantity INTEGER,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);
```

Аналогично работает выражение ON UPDATE CASCADE. При изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. Но так как первичные ключи, как правило, изменяются очень редко, да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение ON UPDATE используется редко.

Установка NULL
При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:

```sql
CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER,
    Quantity INTEGER,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);
```

## Установка значения по умолчанию

```sql
CREATE TABLE Orders
(
    Id SERIAL PRIMARY KEY,
    CustomerId INTEGER DEFAULT 1,
    Quantity INTEGER,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT
);
```
Если для столца значение по умолчанию не задано через параметр DEFAULT, то в качестве такового используется значение NULL (если столбец допускает NULL).

## Изменение таблиц


Нередко возникает изменить уже имеющуюся таблицу, в частности, добавить или удалить столбцы, изменить тип столбцов и т.д.. То есть потребуется изменить определение таблицы. Для этого применяется выражение ALTER TABLE, которое имеет следующий формальный синтаксис:

```sql
ALTER TABLE название_таблицы
{ ADD название_столбца тип_данных_столбца [ограничения_столбца] | 
  DROP COLUMN название_столбца |
  ALTER COLUMN название_столбца параметры_столбца |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}
```

Рассмотрим некоторые возможности по изменению таблицы.

## Добавление нового столбца

Добавим в таблицу Customers новый столбец Phone:

```sql
ALTER TABLE Customers
ADD Phone CHARACTER VARYING(20) NULL;
```


Здесь столбец Phone имеет тип CHARACTER VARYING(20), и для него определен атрибут NULL, то есть столбец допускает отсутствие значения. Но что если нам надо добавить столбец, который не должен принимать значения NULL? Если в таблице есть данные, то следующая команда не будет выполнена:

```sql
ALTER TABLE Customers
ADD Address CHARACTER VARYING(30) NOT NULL;
```

Поэтому в данном случае решение состоит в установке значения по умолчанию через атрибут DEFAULT:

```sql
ALTER TABLE Customers
ADD Address CHARACTER VARYING(30) NOT NULL DEFAULT 'Неизвестно';
```


## Удаление столбца

Удалим столбец Address из таблицы Customers:

```sql
ALTER TABLE Customers
DROP COLUMN Address;
```

## Изменение типа столбца

Для изменения типа применяется ключевое слово TYPE. Изменим в таблице Customers тип данных у столбца FirstName на VARCHAR(50) (он же VARYING CHARACTER(50)):

```sql
ALTER TABLE Customers
ALTER COLUMN FirstName TYPE VARCHAR(50);
```

## Изменение ограничений столбца

Для добавления ограничения применяется оператор SET, после которого указывается ограничение. Например, установим для столбца FirstName ограничение NOT NULL:

```sql
ALTER TABLE Customers 
ALTER COLUMN FirstName 
SET NOT NULL;
```

Для удаления ограничения применяется оператор DROP, после которого указывается ограничение. 
Например, удалим выше установленное ограничение:

```sql
ALTER TABLE Customers 
ALTER COLUMN FirstName 
DROP NOT NULL;
```

## Изменение ограничений таблицы

Добавление ограничения CHECK:


```sql
ALTER TABLE Customers
ADD CHECK (Age > 0);
```

Добавление первичного ключа PRIMARY KEY:

```sql
ALTER TABLE Customers 
ADD PRIMARY KEY (Id);
```


В данном случае предполагается, что в таблице уже есть столбец Id, который не имеет ограничения PRIMARY KEY. А с помощью вышеуказанного скрипта устанавливается ограничение PRIMARY KEY.

Добавление ограничение UNIQUE - определим для столбца Email уникальные значения:

```sql
ALTER TABLE Customers
ADD UNIQUE (Email);
```

При добавлении ограничения каждому из них дается определенное имя. 

Например, выше добавленное ограничение для `CHECK` будет называться `customers_age_check`. 

Имена ограничений можно посмотреть в таблице через pgAdmin.

Также мы можем явным образом назначить ограничению при добавлении имя с помощью оператора CONSTRAINT.

```sql
ALTER TABLE Customers
ADD CONSTRAINT phone_unique UNIQUE (Phone);
```

В данном случае ограничение будет называться "phone_unique".

Чтобы удалить ограничение, надо знать его имя, которое указывается после выражения DROP CONSTRAINT. Например, удалим выше добавленное ограничение:

```sql
ALTER TABLE Customers
DROP CONSTRAINT phone_unique;
```

Переименование столбца и таблицы

Переименуем столбец Address в City:

```sql
ALTER TABLE Customers
RENAME COLUMN Address TO City;
```
Переименуем таблицу Customers в Users:

```sql
ALTER TABLE Customers
RENAME TO Users;
```