Основная цель появления функций в программировании вообще —
упростить решаемую задачу за счет ее декомпозиции на более мелкие
подзадачи. Упрощение достигается за счет того, что о функции можно
думать, абстрагировавшись от «большой» задачи. Для этого функция
определяет четкий интерфейс с внешним миром (параметры
и возвращаемое значение). Ее реализация (тело функции) может
меняться; вызывающая сторона «не видит» этих изменений и не
зависит от них. Этой идеальной ситуации может мешать глобальное
состояние (глобальные переменные), и надо учитывать, что в случае
БД таким состоянием является вся база данных.
В традиционных языках функции часто объединяются в модули
(пакеты, классы для ООП и т. п.), имеющие собственный интерфейс
и реализацию. Границы модулей могут проводиться более или менее
произвольно. Для PostgreSQL есть жесткая граница между клиентской
частью и серверной: серверный код работает с базой, клиентский —
управляет транзакциями. Модули (пакеты) отсутствуют, есть только
пространства имен.
Для традиционных языков единственный минус широкого
использования функций состоит в накладных расходах на их вызов.
Иногда его преодолевают с помощью подстановки (inlining) кода
функции в вызывающую программу. Для БД последствия могут быть
более серьезные: если в функцию выносится часть запроса,
планировщик перестает видеть «общую картину» и не может построить
хороший план. В некоторых случаях PostgreSQL умеет выполнять
подстановку; альтернативные варианты — использование подзапросов
или представлений.


Функции без параметров
Вот простой пример функции без параметров, содержащей один оператор:
=> CREATE FUNCTION hello_world() -- имя и пустой список параметров
RETURNS text -- тип возвращаемого значения
AS $$ SELECT 'Hello, world!'; $$ -- тело
LANGUAGE sql; -- указание языка
CREATE FUNCTION
Тело удобно записывать в строке, заключенной в кавычки-доллары, как в приведенном примере. Иначе придется
заботиться об экранировании кавычек, которые наверняка встретятся в теле функции. Сравните:
=> SELECT ' SELECT ''Hello, world!''; ';
?column?
---------------------------
SELECT 'Hello, world!';
(1 row)
=> SELECT $$ SELECT 'Hello, world!'; $$;
?column?
---------------------------
SELECT 'Hello, world!';
(1 row)
При необходимости кавычки-доллары могут быть вложенными. Для этого в каждой паре кавычек надо использовать
разный текст между долларами:
=> SELECT $func$ SELECT $$Hello, world!$$; $func$;
?column?
-----------------------------
SELECT $$Hello, world!$$;
(1 row)
Функция вызывается в контексте выражения, например:
=> SELECT hello_world(); -- пустые скобки обязательны
hello_world
---------------
Hello, world!
(1 row)
Давайте взглянем на то, как тело функции хранится в системном каталоге.
=> \pset xheader_width 60
Expanded header width is 60.
=> SELECT proname, prosrc, prosqlbody FROM pg_proc
WHERE proname = 'hello_world' \gx
-[ RECORD 1 ]-------------------------
proname | hello_world
prosrc | SELECT 'Hello, world!';
prosqlbody |
Мы видим сохраненную в исходном виде тело-строку.
А теперь реализуем современную возможность пересоздать нашу функцию в другом виде — в стиле стандарта SQL.
В нашем случае телом функции может быть один оператор вида RETURN <выражение>:
=> CREATE OR REPLACE FUNCTION hello_world() RETURNS text
LANGUAGE sql
RETURN 'Hello, world!'