# Функции

Основная цель появления функций в программировании вообще — упростить решаемую задачу за счет ее декомпозиции на более мелкие подзадачи. 

Упрощение достигается за счет того, что о функции можно думать, абстрагировавшись от «большой» задачи. 

Для этого функция определяет четкий интерфейс с внешним миром (параметры и возвращаемое значение). 

Ее реализация (тело функции) может меняться; вызывающая сторона «не видит» этих изменений и не зависит от них. 

Этой идеальной ситуации может мешать глобальное состояние (глобальные переменные), и надо учитывать, что в случае БД таким состоянием является вся база данных.

В традиционных языках функции часто объединяются в модули (пакеты, классы для ООП и т. п.), имеющие собственный интерфейс и реализацию. 

Границы модулей могут проводиться более или менее произвольно. 

Для PostgreSQL есть жесткая граница между клиентской частью и серверной: серверный код работает с базой, клиентский —
управляет транзакциями. 

Модули (пакеты) отсутствуют, есть только пространства имен.

Для традиционных языков единственный минус широкого использования функций состоит в накладных расходах на их вызов.
Иногда его преодолевают с помощью подстановки (inlining) кода функции в вызывающую программу. 

Для БД последствия могут быть более серьезные: если в функцию выносится часть запроса, планировщик перестает видеть «общую картину» и не может построить хороший план. 

В некоторых случаях `PostgreSQL` умеет выполнять подстановку; альтернативные варианты — использование подзапросов или представлений.


## Функции без параметров

Вот простой пример функции без параметров, содержащей один оператор:
```sql
=> CREATE FUNCTION hello_world() -- имя и пустой список параметров
RETURNS text -- тип возвращаемого значения
AS $$ SELECT 'Hello, world!'; $$ -- тело
LANGUAGE sql; -- указание языка
```

Тело удобно записывать в строке, заключенной в кавычки-доллары, как в приведенном примере. 

Иначе придется
заботиться об экранировании кавычек, которые наверняка встретятся в теле функции. 

Сравните:
```sql
SELECT ' SELECT ''Hello, world!''; ';

---------------------------
SELECT 'Hello, world!';
(1 row)
=> SELECT $$ SELECT 'Hello, world!'; $$;
?column?
---------------------------
SELECT 'Hello, world!';
(1 row)
```
При необходимости кавычки-доллары могут быть вложенными. 

Для этого в каждой паре кавычек надо использовать разный текст между долларами:
```sql
=> SELECT $func$ SELECT $$Hello, world!$$; $func$;
?column?
-----------------------------
SELECT $$Hello, world!$$;
(1 row)
```
Функция вызывается в контексте выражения, например:
```sql
=> SELECT hello_world(); -- пустые скобки обязательны
hello_world
---------------
Hello, world!
(1 row)
```


А теперь реализуем современную возможность пересоздать нашу функцию в другом виде — в стиле стандарта SQL.

В нашем случае телом функции может быть один оператор вида RETURN <выражение>:
```sql
CREATE OR REPLACE FUNCTION hello_world() RETURNS text
RETURN 'Hello, world!'
```


## Функции с входными параметрами

```sql
CREATE or replace FUNCTION hello(name text) -- формальный параметр
RETURNS text
RETURN 'Hello, ' || name || '!';


SELECT  hello('Анна');
```


Можно определить параметр функции без имени; тогда внутри тела функции на параметры придется ссылаться по
номеру.

Удалим функцию и создадим новую

```sql
CREATE or replace FUNCTION hello(text)
RETURNS text
RETURN 'Hello, ' || $1 || '!';

```
Напишем функцию, возвращающую большее из двух целых чисел. 
(Похожее выражение есть в
SQL и называется greatest, но мы напишем собственную функцию).

```sql
CREATE FUNCTION maximum(a integer, b integer)
RETURNS integer
RETURN CASE WHEN a > b THEN a ELSE b END;
```

SELECT maximum(10,20);


## Функции с выходными параметрами

```sql
CREATE FUNCTION hello(
IN name text,
OUT text
)
RETURN 'Hello, ' || name || '!';
```

Или даже так, использовав `INOUT`-параметр:

```sql
CREATE FUNCTION hello(INOUT name text)
RETURN 'Hello, ' || name || '!';
```


Обратите внимание, что, в отличие от многих языков программирования, фактическое значение, переданное SQL-
функции в `INOUT-параметре`, никак не изменяется: мы передаем входное значение, а выходное возвращается
функцией в качестве результата. 

Поэтому мы можем указать константу, хотя другие языки требовали бы переменную.
В то время как в `RETURNS` можно указать только одно значение, выходных параметров может быть несколько.
Например:

```sql
СREATE FUNCTION hello(
    IN name text,
    OUT greeting text,
    OUT clock timetz)
    LANGUAGE sql
    RETURN ('Hello, ' || name || '!', current_time);
```


```sql
CREATE or REPLACE FUNCTION get_product(numb integerS)
RETURNS text
RETURN (
	SELECT productname from products
	LIMIT 1 OFFSET numb
);

SELECT get_product(2);

```


![alt text](image-9.png)


## Корни квадратного уравнения

```sql
CREATE or REPLACE FUNCTION square_roots(
	a float,
	b float,
	c float,
	x1 OUT float,
	x2 OUT float
	)

RETURN (
WITH discriminant(d) AS (SELECT b * b - 4*a*c)
SELECT (
	CASE WHEN d >= 0.0
	THEN
		(-b + sqrt(d))/ (2 * a)
		END,
	CASE WHEN d > 0.0
	THEN
		(-b - sqrt(d))/ (2 * a) 
		END
		)
FROM discriminant
);

SELECT square_roots(1, 0, -4);
SELECT square_roots(1, -4, 4);
SELECT square_roots(1, 1, 1);
```

![alt text](image-10.png)